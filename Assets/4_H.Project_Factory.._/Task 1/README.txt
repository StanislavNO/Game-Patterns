	Фабрика:
	
	Абстрактная фабрика и фабричный метод
Тип: порождающий паттерн
Цель использования: инкапсуляция создания объекта или семейства объектов и изоляции этой информации от основной части кода
Возможные примеры использования:
•	Создание различных типов врагов (или конфигураций врагов)
•	Спавн различных типов монет
•	Создание различных типов сеток для стратегии
•	Несколько кузнецов, которые создают свой тип оружия
•	Создание элементов окружения
•	Создание элементов интерфейса (например отображение монет может быть различным в зависимости от сцены: магазин, геймплей, главное меню. Или звезды за прохождение уровня и тп)
•	Создание способностей
•	Создание предметов и т.д.
Отличие абстрактной фабрики и фабричного метода главным образом заключается в том, что абстрактная фабрика используется для создания семейства объектов и обычно передается контексту нужная фабрика, а фабричный метод реализуется чисто наследованием и переопределением метода создания (подробнее в уроке)
Примерные этапы использования:
1.	Определить создание каких сущностей стоит вынести в отдельное место
2.	Создать класс фабрики и допустим метод Get который, возвращает нужную сущность под абстракцией (например Enemy)
3.	Определить передаваемые параметры для инициализации (или передавать необходимые сущности при создании или инициализации фабрики)
4.	Далее либо по типу возвращать проинициализированный объект, либо более классически создавать наследников, где каждый наследник создает свой тип сущности (например одна фабрика создает врагов орков, а другая врагов эльфов)
5.	Использовать получившуюся фабрику в контексте (например в спавнере врагов)


	Визитер:

Тип: поведенческий паттерн
Цель использования: помогает описать операцию, выполняемую с каждым объектом некоторой иерархии классов не прибегая при этом к изменению этих классов.
Возможные примеры использования:
•	Подсчет очков, в зависимости от типа врага
•	Подсчитывание веса врага для их спавна (например, останавливать спавнер, если вес врагов на карте достиг максимального)
•	Разная обработка попадания от различного вида оружия
•	Создание объекта в фабрике с зависимости от типа передаваемой конфигурации (например, передаем конфигурацию орка и с помощью визитера создаем префаб орка)
•	В зависимости от типа объекта на сетке обрабатывать коллизии (например, хотим поставить врага на клетку, где стоит ловушка, с помощью визитера можем матчить эту иерархию размещаемых на сетке объектов и смотреть можно ли ставить разные типы в одну клетку)
•	В целом любой вариант, где нужно пройтись по иерархии для совершения какого – то действия
Примерные этапы использования:
1.	Определить иерархию классов, с которой надо совершить какое-то действие в зависимости от члена иерархии
2.	Создаем интерфейс визитера и делаем по методу Visit на каждый элемент иерархии
3.	Классический способ предусматривает создание метода Accept у всех членов иерархии (включая базовый и переопределение этого метода у дочерних). Но можно сделать реализацию через dynamic (оба этих способа показаны в уроке)
4.	Создаем в нужном месте приватный класс визитера и реализуем на нем созданный интерфейс. Далее в каждом методе реализуем нужную логику для каждого типа и потом можно из этого визитера считывать данные когда нужно. 
5.	Важно не забывать очищать данные визитера, если это необходимо, чтобы не возникало ошибок. (опять-таки подробная реализация приведена в уроке)


	Декоратор:

Тип: структурный паттерн
Цель использования: динамически добавляет объекту новые свойства.
Возможные примеры использования:
•	Реализация различных видов здоровья с разными свойствами (как в примере с урока, где разные варианты хп по разному обрабатывают хил и тп). Благодаря такому подходу можно создавать новые виды хп и из комбинации предыдущих
•	Реализация эффектов от одежды как вариант
•	Переопределение статов персонажа в зависимости от расы/специализации и т.п.
•	Возможность работы с чужим кодом, не меняя его изнутри (можно иногда оборачивать код, для добавления нового функционала)
•	Использование декоратора для отображения результатов выполнения в консоли (например делаем специальный класс, который будет оборачивать другой и он просто будет переопределять методы отображением нужных значений в консоль). Таким образом можно не засорять код всякими консольными выводами и прочим.
•	Любая другая ситуация, где хорошо ложится композиция (т.е. вот такой вариант с оберткой одних классов вокруг других, для получения комбинации свойств)
Примерные этапы использования:
1.	Определить общий интерфейс для нескольких сущностей, которые будем оборачивать между собой (это может быть абстрактный класс или интерфейс, например, хп как в примере с урока)
2.	Реализовать все сущности от этого интерфейса. В конструкторе же каждой сущности будет приниматься объект под созданным интерфейсом и какая-то дополнительная информация необходимая конкретной сущности (как в примере с урока для бронированых хп надо передать IHealth и параметр защиты)
3.	Далее использовать в контексте в различных комбинациях (например, создать персонажа с комбинирующимися хп)


